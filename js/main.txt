//http://bl.ocks.org/zanarmstrong/b1c051113be144570881


var margin = {top: 20, right: 20, bottom: 20, left: 30},
    padding = {top: 20, right: 60, bottom: 60, left: 30},
    outerWidth = 960,
    outerHeight = 500,
    innerWidth = outerWidth - margin.left - margin.right,
    innerHeight = outerHeight - margin.top - margin.bottom,
    width = innerWidth - padding.left - padding.right,
    height = innerHeight - padding.top - padding.bottom;

var x = d3.scaleIdentity()
    .domain([0, width]);

var y = d3.scaleIdentity()
    .domain([0, height]);

var xAxis = d3.axisBottom()
    .scale(x)

var yAxis = d3.axisRight()
    .scale(y)

var svg = d3.select("body").append("svg")
    
var g = svg.attr("width", outerWidth)
    .attr("height", outerHeight)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var voronoi_group = g.append("g").attr("class", "voronoi_group")

var demand_data_lines_group = g.append("g").attr("class", "demand_data_lines_group")
var demand_data_circles_group = g.append("g").attr("class", "demand_data_circles_group")

var locations_group = g.append("g").attr("class", "locations_group")


svg.on("click", function(){
  update_dots(d3.mouse(this))
})


function get_random_location() {
    return [d3.randomUniform(0,width)(),d3.randomUniform(0,height)()] 
}

var demand_data = _.map(d3.range(500), get_random_location)
var demand_data = _.map(demand_data, function(d) {return {point:d, demand: d3.randomUniform(0,100)()}})

var demand_colour_scale = d3.scaleLinear().domain([0,50,100]).range(["#6AE817","#FFA200", "#B30409"])

// var original_locations = _.map(d3.range(3), get_random_location)

// Plot demand data
demand_data_circles_group.selectAll(".demand_data").data(demand_data)
    .enter()
    .append("circle")
    .attr("r", 3)
    .attr("cx", function(d) {return d.point[0]})
    .attr("cy", function(d) {return d.point[1]})
    .attr("fill", function(d) {return demand_colour_scale(d.demand)})
    .attr("class", "demand_data")

demand_data_lines_group.selectAll(".demand_data_lines").data(demand_data)
    .enter()
    .append("line")
    .attr("class", "demand_data_lines")

//Function for voronoi
var my_voronoi = d3.voronoi()
                .x(function(d) {
                    return d.point[0];
                })
                .y(function(d) {
                    return d.point[1];
                })
                .extent([[0, 0], [width, height]])

var locations = []

locations_group.append("text").text("").attr("class", "loss_text")
    .attr("x", width)
    .attr("y", height+20)
    .attr("text-anchor", "end")

function update_dots(point) {

    point[0] = point[0] - margin.left
    point[1] = point[1] - margin.top


    new_location = {
        point:point,
        name: locations.length + 1
    }

    locations.push(new_location)

    redraw_voronoi()

}

var drag = d3.drag()
    .on("drag", dragged)
    
function dragged(d) {
    d.y = d3.event.y
    d.x = d3.event.x

  // d3.select(this).attr("cx", d.x = d3.event.x).attr("cy", );

  this.__data__.data.point = [d3.event.x, d3.event.y]

  //update locations data
  locations = d3.selectAll(".locations_circles").data()
  locations = _.map(locations, function(d) {return d.data})
 
  redraw_voronoi()
}



function redraw_voronoi() {
    
    var diagram = my_voronoi.polygons(locations)

    function path_generator(d) {
        return d ? "M" + d.join("L") + "Z" : null
    }

    var v_cells = voronoi_group.selectAll(".voronoicells")
        .data(diagram)
    
    v_cells.enter().append("path").merge(v_cells)
        .attr("class", "voronoicells")
        .attr("d", function(d) {
            return path_generator(d)})

    var circles = locations_group.selectAll(".locations_circles")
        .data(diagram)
    
    circles = circles.enter().append("circle")
        .attr("r", function(d) {
            return 7})
        .attr("class", "locations_circles")
        .call(drag)
        .merge(circles)
        .attr("cx", function(d) {
            return  d.data.point[0]
        })
        .attr("cy", function(d) {return d.data.point[1]})

    compute_loss()

}

function compute_loss() {
    //Iterate through the demand_data.
    //For each point find the closest location
    //And compute the distance
    //And draw line to closest 

    var lines_data = _.map(demand_data, function(d) {
        var closest_point = get_closest_point(d)["point"]

        var this_distance = get_distance(d.point, closest_point)

        return {this_point: d.point, closest_point:closest_point, distance:this_distance}
    })

    // Get min and max distance
    var min_distance = _.min(lines_data, function(d) {return d.distance})["distance"]
    var max_distance = _.max(lines_data, function(d) {return d.distance})["distance"]

    var distance_line_colour_scale = d3.scaleLinear().domain([min_distance, max_distance]).range([ "#04CE4E","#CE043A"])


    demand_data_lines_group.selectAll(".demand_data_lines").data(lines_data)
        .attr("x1", function(d) {return d.this_point[0]})
        .attr("y1", function(d) {return d.this_point[1]})
        .attr("x2", function(d) {return d.closest_point[0]})
        .attr("y2", function(d) {return d.closest_point[1]})
        .style("stroke", function(d) {
            return distance_line_colour_scale(d.distance)})
        .style("stroke-width",1)

    var distances = _.map(lines_data, function(d) {
        return get_distance(d.this_point, d.closest_point)
    })

    var total_distance = _.reduce(distances, function(a,b) {return a+b})



    locations_group.select(".loss_text").text("Total loss: " + d3.format(",.0f")(total_distance))





}



function get_closest_point(point) {
    locations = _.sortBy(locations, function(this_location) {
       return get_distance(this_location.point, point.point)
    })
    return locations[0]

}

function get_distance(p1, p2) {
    a2=  Math.pow((p1[0] - p2[0]),2)
    b2 = Math.pow((p1[1] - p2[1]),2)
    return Math.pow(a2+b2,0.5)
}

function point_to_plot_location(point) {
    return [point[0] + margin]
}